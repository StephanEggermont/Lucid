# Lucid - `CoreManagerContainer`

`CoreManagerContainer` is convenience object generated by Lucid which contains one core manager per entity type.

Although it isn't required, we recommend using the CoreManagerContainer, as it facilitates the use of managers accross the project and avoids data synchronization issues.

## Data Synchronization

To understand why the container is useful, it's important to understand certain rules about core managers and data synchronization.

- Core manager instances aren't synchronized with each other. This means that **writing data with one instance** of a core manager **won't** necessarily **update continuous publishers of other instances** of the same entity type.

- Core managers have an internal synchronization system in order to avoid overriding fresh data with outdated data. While this system doesn't share its state with other instances, it may share the same stores. Such a setup can lead to **data collisions** and **damage local stores' integrity**.

Generally speaking, it is adviced to use only one core manager instance per entity type in a project, which is where `CoreManagerContainer` comes handy.

## Initialization

Buiding a `CoreManagerContainer` looks like the following:

```swift
let coreManagers = CoreManagerContainer(
  cacheLimit: 512,
  client: MyAPIClient(...),
  diskStoreConfig: .coreData  
)

coreManagers.myEntityManager.get(byID: ...)
```

The `CoreManagerContainer` depends on two objects:

1. [`APIClient`](./Client.md): An interface to your network APIs
2. `DiskStoreConfig`: A struct containing any needed data to build your disk stores.

By default, core managers are using an `InMemoryStore` as a caching system in front of a `CoreDataStore`. That's why it is required to set the `cacheLimit` to a reasonable value as it is the maximum amount of entities the `InMemoryStore` can contain per entity type.

## Default Store Configuration

`CoreManagerContainer` automatically creates the stores which are being injected into the core managers. 

By default, it uses the following:

- `LocalEntity` => `InMemoryStore`
- `CoreDataEntity`=> `InMemoryStore` + `CoreDataStore`
- `RemoteEntity` => `RemoteStore`
- `CoreDataEntity` + `RemoteEntity` => `InMemoryStore` + `CoreDataStore` + `RemoteStore`

## Custom Store Configuration

`CoreManagerContainer` provides a way to use your own configuration of stores for a type of entity. 

Here's how to do so:

```swift
extension MyEntityType {
  
  static func stores(with client: APIClient,
                     clientQueue: inout APIClientQueue,
                     cacheLimit: Int,
                     diskStoreConfig: CoreManagerContainer.DiskStoreConfig) -> [Storing<MyEntityType>] { 
    return [...]
  }
}
```

Note that `DiskStoreConfig` has a custom property which can be any type of data you want to inject in order to build your own local stores.
