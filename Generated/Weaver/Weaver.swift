import UIKit

// swiftlint:disable all
/// This file is generated by Weaver 1.0.6
/// DO NOT EDIT!

final class MainDependencyContainer {

    static var onFatalError: (String, StaticString, UInt) -> Never = { message, file, line in
        Swift.fatalError(message, file: file, line: line)
    }

    fileprivate static func fatalError(file: StaticString = #file, line: UInt = #line) -> Never {
        onFatalError("Invalid memory graph. This is never suppose to happen. Please file a ticket at https://github.com/scribd/Weaver", file, line)
    }

    private typealias ParametersCopier = (MainDependencyContainer) -> Void
    private typealias Builder<T> = (ParametersCopier?) -> T

    private func builder<T>(_ value: T) -> Builder<T> {
        return { [weak self] copyParameters in
            guard let self = self else {
                MainDependencyContainer.fatalError()
            }
            copyParameters?(self)
            return value
        }
    }

    private func weakOptionalBuilder<T>(_ value: Optional<T>) -> Builder<Optional<T>> where T: AnyObject {
        return { [weak value] _ in value }
    }

    private func weakBuilder<T>(_ value: T) -> Builder<T> where T: AnyObject {
        return { [weak self, weak value] copyParameters in
            guard let self = self, let value = value else {
                MainDependencyContainer.fatalError()
            }
            copyParameters?(self)
            return value
        }
    }

    private func lazyBuilder<T>(_ builder: @escaping Builder<T>) -> Builder<T> {
        var _value: T?
        return { copyParameters in
            if let value = _value {
                return value
            }
            let value = builder(copyParameters)
            _value = value
            return value
        }
    }

    private func weakLazyBuilder<T>(_ builder: @escaping Builder<T>) -> Builder<T> where T: AnyObject {
        weak var _value: T?
        return { copyParameters in
            if let value = _value {
                return value
            }
            let value = builder(copyParameters)
            _value = value
            return value
        }
    }

    private static func fatalBuilder<T>() -> Builder<T> {
        return { _ in
            MainDependencyContainer.fatalError()
        }
    }

    private var builders = Dictionary<String, Any>()
    private func getBuilder<T>(for name: String, type _: T.Type) -> Builder<T> {
        guard let builder = builders[name] as? Builder<T> else {
            return MainDependencyContainer.fatalBuilder()
        }
        return builder
    }

    private static var _dynamicResolvers = [Any]()
    private static var _dynamicResolversLock = NSRecursiveLock()

    fileprivate static func _popDynamicResolver<Resolver>(_ resolverType: Resolver.Type) -> Resolver {
        guard let dynamicResolver = _dynamicResolvers.removeFirst() as? Resolver else {
            MainDependencyContainer.fatalError()
        }
        return dynamicResolver
    }

    static func _pushDynamicResolver<Resolver>(_ resolver: Resolver) {
        _dynamicResolvers.append(resolver)
    }

    enum Scope {
        case transient
        case container
        case weak
        case lazy
    }

    enum Platform {
        case OSX
        case macOS
        case iOS
        case watchOS
        case tvOS
    }

    enum DependencyKind {
        case registration
        case reference
        case parameter
    }

    var logger: Int {
        return getBuilder(for: "logger", type: Int.self)(nil)
    }

    fileprivate init() {
    }

    fileprivate func appDelegateDependencyResolver() -> AppDelegateDependencyResolver {
        let _self = MainDependencyContainer()
        _self.builders["logger"] = lazyBuilder { (_: Optional<ParametersCopier>) -> Int in return Int() }
        _ = _self.getBuilder(for: "logger", type: Int.self)(nil)
        MainDependencyContainer._pushDynamicResolver({ _self.logger })
        return _self
    }

    static func appDelegateDependencyResolver() -> AppDelegateDependencyResolver {
        let _self = MainDependencyContainer().appDelegateDependencyResolver()
        return _self
    }
}


protocol LoggerResolver: AnyObject {
    var logger: Int { get }
}

extension MainDependencyContainer: LoggerResolver {
}

extension MainDependencyContainer {
}

typealias AppDelegateDependencyResolver = LoggerResolver

@propertyWrapper
struct Weaver<ConcreteType, AbstractType> {

    typealias Resolver = () -> AbstractType
    let resolver = MainDependencyContainer._popDynamicResolver(Resolver.self)

    init(_ kind: MainDependencyContainer.DependencyKind,
         type: ConcreteType.Type,
         scope: MainDependencyContainer.Scope = .container,
         setter: Bool = false,
         escaping: Bool = false,
         builder: Optional<Any> = nil,
         objc: Bool = false,
         platforms: Array<MainDependencyContainer.Platform> = []) {
        // no-op
    }

    var wrappedValue: AbstractType {
        return resolver()
    }
}

extension Weaver where ConcreteType == Void {
    init(_ kind: MainDependencyContainer.DependencyKind,
         scope: MainDependencyContainer.Scope = .container,
         setter: Bool = false,
         escaping: Bool = false,
         builder: Optional<Any> = nil,
         objc: Bool = false,
         platforms: Array<MainDependencyContainer.Platform> = []) {
        // no-op
    }
}
